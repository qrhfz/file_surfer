// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	AccessTokenScopes = "accessToken.Scopes"
	TokenScopes       = "token.Scopes"
)

// Defines values for Role.
const (
	Admin   Role = "admin"
	Regular Role = "regular"
)

// File defines model for File.
type File struct {
	Location *string    `json:"location,omitempty"`
	Modified *time.Time `json:"modified,omitempty"`
	Name     *string    `json:"name,omitempty"`
	Size     *int       `json:"size,omitempty"`
	Type     *string    `json:"type,omitempty"`
}

// Folder defines model for Folder.
type Folder struct {
	Location *string    `json:"location,omitempty"`
	Modified *time.Time `json:"modified,omitempty"`
	Name     *string    `json:"name,omitempty"`
	Size     *int       `json:"size,omitempty"`
}

// Role defines model for Role.
type Role string

// User defines model for User.
type User struct {
	Id       *string `json:"id,omitempty"`
	Role     *Role   `json:"role,omitempty"`
	Username *string `json:"username,omitempty"`
}

// LocationPath defines model for LocationPath.
type LocationPath = string

// FolderContent defines model for FolderContent.
type FolderContent struct {
	Files   *[]File   `json:"files,omitempty"`
	Folders *[]Folder `json:"folders,omitempty"`
}

// GetBlobParams defines parameters for GetBlob.
type GetBlobParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PostBlobMultipartBody defines parameters for PostBlob.
type PostBlobMultipartBody struct {
	Files *[][]byte `json:"files,omitempty"`
}

// PostBlobParams defines parameters for PostBlob.
type PostBlobParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PostCopyJSONBody defines parameters for PostCopy.
type PostCopyJSONBody struct {
	Destination string   `json:"destination"`
	Sources     []string `json:"sources"`
}

// DeleteFileParams defines parameters for DeleteFile.
type DeleteFileParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// GetFileParams defines parameters for GetFile.
type GetFileParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PatchFileJSONBody defines parameters for PatchFile.
type PatchFileJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// PatchFileParams defines parameters for PatchFile.
type PatchFileParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PostFileJSONBody defines parameters for PostFile.
type PostFileJSONBody struct {
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
}

// PostFileParams defines parameters for PostFile.
type PostFileParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// DeleteFolderParams defines parameters for DeleteFolder.
type DeleteFolderParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// GetFolderParams defines parameters for GetFolder.
type GetFolderParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PatchFolderJSONBody defines parameters for PatchFolder.
type PatchFolderJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// PatchFolderParams defines parameters for PatchFolder.
type PatchFolderParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PostFolderParams defines parameters for PostFolder.
type PostFolderParams struct {
	Path LocationPath `form:"path" json:"path"`
}

// PostLoginJSONBody defines parameters for PostLogin.
type PostLoginJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// PostMoveJSONBody defines parameters for PostMove.
type PostMoveJSONBody struct {
	Destination string   `json:"destination"`
	Sources     []string `json:"sources"`
}

// GetSearchParams defines parameters for GetSearch.
type GetSearchParams struct {
	Path        string `form:"path" json:"path"`
	SearchQuery string `form:"searchQuery" json:"searchQuery"`
}

// PatchUserIdJSONBody defines parameters for PatchUserId.
type PatchUserIdJSONBody struct {
	Password *string `json:"password,omitempty"`
	Role     *Role   `json:"role,omitempty"`
	Username *string `json:"username,omitempty"`
}

// PostUserIdJSONBody defines parameters for PostUserId.
type PostUserIdJSONBody struct {
	Password *string `json:"password,omitempty"`
	Role     *Role   `json:"role,omitempty"`
	Username *string `json:"username,omitempty"`
}

// PostBlobMultipartRequestBody defines body for PostBlob for multipart/form-data ContentType.
type PostBlobMultipartRequestBody PostBlobMultipartBody

// PostCopyJSONRequestBody defines body for PostCopy for application/json ContentType.
type PostCopyJSONRequestBody PostCopyJSONBody

// PatchFileJSONRequestBody defines body for PatchFile for application/json ContentType.
type PatchFileJSONRequestBody PatchFileJSONBody

// PostFileJSONRequestBody defines body for PostFile for application/json ContentType.
type PostFileJSONRequestBody PostFileJSONBody

// PatchFolderJSONRequestBody defines body for PatchFolder for application/json ContentType.
type PatchFolderJSONRequestBody PatchFolderJSONBody

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody PostLoginJSONBody

// PostMoveJSONRequestBody defines body for PostMove for application/json ContentType.
type PostMoveJSONRequestBody PostMoveJSONBody

// PatchUserIdJSONRequestBody defines body for PatchUserId for application/json ContentType.
type PatchUserIdJSONRequestBody PatchUserIdJSONBody

// PostUserIdJSONRequestBody defines body for PostUserId for application/json ContentType.
type PostUserIdJSONRequestBody PostUserIdJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccessToken request
	GetAccessToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlob request
	GetBlob(ctx context.Context, params *GetBlobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBlob request with any body
	PostBlobWithBody(ctx context.Context, params *PostBlobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCopy request with any body
	PostCopyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCopy(ctx context.Context, body PostCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFile request
	DeleteFile(ctx context.Context, params *DeleteFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, params *GetFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchFile request with any body
	PatchFileWithBody(ctx context.Context, params *PatchFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchFile(ctx context.Context, params *PatchFileParams, body PatchFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFile request with any body
	PostFileWithBody(ctx context.Context, params *PostFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFile(ctx context.Context, params *PostFileParams, body PostFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, params *DeleteFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolder request
	GetFolder(ctx context.Context, params *GetFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchFolder request with any body
	PatchFolderWithBody(ctx context.Context, params *PatchFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchFolder(ctx context.Context, params *PatchFolderParams, body PatchFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFolder request
	PostFolder(ctx context.Context, params *PostFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLogin request with any body
	PostLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLogin(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMove request with any body
	PostMoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMove(ctx context.Context, body PostMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearch request
	GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserId request
	DeleteUserId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserId request with any body
	PatchUserIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserId(ctx context.Context, id string, body PatchUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserId request with any body
	PostUserIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserId(ctx context.Context, id string, body PostUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccessToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlob(ctx context.Context, params *GetBlobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlobWithBody(ctx context.Context, params *PostBlobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlobRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCopyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCopyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCopy(ctx context.Context, body PostCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCopyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFile(ctx context.Context, params *DeleteFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, params *GetFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFileWithBody(ctx context.Context, params *PatchFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFile(ctx context.Context, params *PatchFileParams, body PatchFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFileWithBody(ctx context.Context, params *PostFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFile(ctx context.Context, params *PostFileParams, body PostFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, params *DeleteFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolder(ctx context.Context, params *GetFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFolderWithBody(ctx context.Context, params *PatchFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFolderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFolder(ctx context.Context, params *PatchFolderParams, body PatchFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFolderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFolder(ctx context.Context, params *PostFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFolderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLogin(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMoveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMove(ctx context.Context, body PostMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMoveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearch(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserId(ctx context.Context, id string, body PatchUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserId(ctx context.Context, id string, body PostUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccessTokenRequest generates requests for GetAccessToken
func NewGetAccessTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlobRequest generates requests for GetBlob
func NewGetBlobRequest(server string, params *GetBlobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blob")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBlobRequestWithBody generates requests for PostBlob with any type of body
func NewPostBlobRequestWithBody(server string, params *PostBlobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blob")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCopyRequest calls the generic PostCopy builder with application/json body
func NewPostCopyRequest(server string, body PostCopyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCopyRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCopyRequestWithBody generates requests for PostCopy with any type of body
func NewPostCopyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/copy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFileRequest generates requests for DeleteFile
func NewDeleteFileRequest(server string, params *DeleteFileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, params *GetFileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchFileRequest calls the generic PatchFile builder with application/json body
func NewPatchFileRequest(server string, params *PatchFileParams, body PatchFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchFileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchFileRequestWithBody generates requests for PatchFile with any type of body
func NewPatchFileRequestWithBody(server string, params *PatchFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFileRequest calls the generic PostFile builder with application/json body
func NewPostFileRequest(server string, params *PostFileParams, body PostFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFileRequestWithBody generates requests for PostFile with any type of body
func NewPostFileRequestWithBody(server string, params *PostFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, params *DeleteFolderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderRequest generates requests for GetFolder
func NewGetFolderRequest(server string, params *GetFolderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchFolderRequest calls the generic PatchFolder builder with application/json body
func NewPatchFolderRequest(server string, params *PatchFolderParams, body PatchFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchFolderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchFolderRequestWithBody generates requests for PatchFolder with any type of body
func NewPatchFolderRequestWithBody(server string, params *PatchFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFolderRequest generates requests for PostFolder
func NewPostFolderRequest(server string, params *PostFolderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLoginRequest calls the generic PostLogin builder with application/json body
func NewPostLoginRequest(server string, body PostLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLoginRequestWithBody generates requests for PostLogin with any type of body
func NewPostLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMoveRequest calls the generic PostMove builder with application/json body
func NewPostMoveRequest(server string, body PostMoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMoveRequestWithBody(server, "application/json", bodyReader)
}

// NewPostMoveRequestWithBody generates requests for PostMove with any type of body
func NewPostMoveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/move")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchRequest generates requests for GetSearch
func NewGetSearchRequest(server string, params *GetSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchQuery", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserIdRequest generates requests for DeleteUserId
func NewDeleteUserIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserIdRequest calls the generic PatchUserId builder with application/json body
func NewPatchUserIdRequest(server string, id string, body PatchUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchUserIdRequestWithBody generates requests for PatchUserId with any type of body
func NewPatchUserIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUserIdRequest calls the generic PostUserId builder with application/json body
func NewPostUserIdRequest(server string, id string, body PostUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostUserIdRequestWithBody generates requests for PostUserId with any type of body
func NewPostUserIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccessToken request
	GetAccessTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessTokenResponse, error)

	// GetBlob request
	GetBlobWithResponse(ctx context.Context, params *GetBlobParams, reqEditors ...RequestEditorFn) (*GetBlobResponse, error)

	// PostBlob request with any body
	PostBlobWithBodyWithResponse(ctx context.Context, params *PostBlobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlobResponse, error)

	// PostCopy request with any body
	PostCopyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCopyResponse, error)

	PostCopyWithResponse(ctx context.Context, body PostCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCopyResponse, error)

	// DeleteFile request
	DeleteFileWithResponse(ctx context.Context, params *DeleteFileParams, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error)

	// GetFile request
	GetFileWithResponse(ctx context.Context, params *GetFileParams, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// PatchFile request with any body
	PatchFileWithBodyWithResponse(ctx context.Context, params *PatchFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFileResponse, error)

	PatchFileWithResponse(ctx context.Context, params *PatchFileParams, body PatchFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFileResponse, error)

	// PostFile request with any body
	PostFileWithBodyWithResponse(ctx context.Context, params *PostFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFileResponse, error)

	PostFileWithResponse(ctx context.Context, params *PostFileParams, body PostFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFileResponse, error)

	// DeleteFolder request
	DeleteFolderWithResponse(ctx context.Context, params *DeleteFolderParams, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// GetFolder request
	GetFolderWithResponse(ctx context.Context, params *GetFolderParams, reqEditors ...RequestEditorFn) (*GetFolderResponse, error)

	// PatchFolder request with any body
	PatchFolderWithBodyWithResponse(ctx context.Context, params *PatchFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFolderResponse, error)

	PatchFolderWithResponse(ctx context.Context, params *PatchFolderParams, body PatchFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFolderResponse, error)

	// PostFolder request
	PostFolderWithResponse(ctx context.Context, params *PostFolderParams, reqEditors ...RequestEditorFn) (*PostFolderResponse, error)

	// PostLogin request with any body
	PostLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLoginResponse, error)

	PostLoginWithResponse(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLoginResponse, error)

	// PostMove request with any body
	PostMoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMoveResponse, error)

	PostMoveWithResponse(ctx context.Context, body PostMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMoveResponse, error)

	// GetSearch request
	GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error)

	// DeleteUserId request
	DeleteUserIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserIdResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// PatchUserId request with any body
	PatchUserIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserIdResponse, error)

	PatchUserIdWithResponse(ctx context.Context, id string, body PatchUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserIdResponse, error)

	// PostUserId request with any body
	PostUserIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserIdResponse, error)

	PostUserIdWithResponse(ctx context.Context, id string, body PostUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserIdResponse, error)
}

type GetAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessToken *string `json:"accessToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r PostCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content *string `json:"content,omitempty"`
		Info    *File   `json:"info,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Files   *[]File   `json:"files,omitempty"`
		Folders *[]Folder `json:"folders,omitempty"`
	}
	XML200 *struct {
		Empty *string `json:",omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON401 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r PostMoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Files   *[]File   `json:"files,omitempty"`
		Folders *[]Folder `json:"folders,omitempty"`
	}
	XML200 *struct {
		Empty *string `json:",omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccessTokenWithResponse request returning *GetAccessTokenResponse
func (c *ClientWithResponses) GetAccessTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccessTokenResponse, error) {
	rsp, err := c.GetAccessToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessTokenResponse(rsp)
}

// GetBlobWithResponse request returning *GetBlobResponse
func (c *ClientWithResponses) GetBlobWithResponse(ctx context.Context, params *GetBlobParams, reqEditors ...RequestEditorFn) (*GetBlobResponse, error) {
	rsp, err := c.GetBlob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlobResponse(rsp)
}

// PostBlobWithBodyWithResponse request with arbitrary body returning *PostBlobResponse
func (c *ClientWithResponses) PostBlobWithBodyWithResponse(ctx context.Context, params *PostBlobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlobResponse, error) {
	rsp, err := c.PostBlobWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlobResponse(rsp)
}

// PostCopyWithBodyWithResponse request with arbitrary body returning *PostCopyResponse
func (c *ClientWithResponses) PostCopyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCopyResponse, error) {
	rsp, err := c.PostCopyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCopyResponse(rsp)
}

func (c *ClientWithResponses) PostCopyWithResponse(ctx context.Context, body PostCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCopyResponse, error) {
	rsp, err := c.PostCopy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCopyResponse(rsp)
}

// DeleteFileWithResponse request returning *DeleteFileResponse
func (c *ClientWithResponses) DeleteFileWithResponse(ctx context.Context, params *DeleteFileParams, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error) {
	rsp, err := c.DeleteFile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResponse(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, params *GetFileParams, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// PatchFileWithBodyWithResponse request with arbitrary body returning *PatchFileResponse
func (c *ClientWithResponses) PatchFileWithBodyWithResponse(ctx context.Context, params *PatchFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFileResponse, error) {
	rsp, err := c.PatchFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFileResponse(rsp)
}

func (c *ClientWithResponses) PatchFileWithResponse(ctx context.Context, params *PatchFileParams, body PatchFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFileResponse, error) {
	rsp, err := c.PatchFile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFileResponse(rsp)
}

// PostFileWithBodyWithResponse request with arbitrary body returning *PostFileResponse
func (c *ClientWithResponses) PostFileWithBodyWithResponse(ctx context.Context, params *PostFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFileResponse, error) {
	rsp, err := c.PostFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFileResponse(rsp)
}

func (c *ClientWithResponses) PostFileWithResponse(ctx context.Context, params *PostFileParams, body PostFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFileResponse, error) {
	rsp, err := c.PostFile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFileResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, params *DeleteFolderParams, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// GetFolderWithResponse request returning *GetFolderResponse
func (c *ClientWithResponses) GetFolderWithResponse(ctx context.Context, params *GetFolderParams, reqEditors ...RequestEditorFn) (*GetFolderResponse, error) {
	rsp, err := c.GetFolder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderResponse(rsp)
}

// PatchFolderWithBodyWithResponse request with arbitrary body returning *PatchFolderResponse
func (c *ClientWithResponses) PatchFolderWithBodyWithResponse(ctx context.Context, params *PatchFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFolderResponse, error) {
	rsp, err := c.PatchFolderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFolderResponse(rsp)
}

func (c *ClientWithResponses) PatchFolderWithResponse(ctx context.Context, params *PatchFolderParams, body PatchFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFolderResponse, error) {
	rsp, err := c.PatchFolder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFolderResponse(rsp)
}

// PostFolderWithResponse request returning *PostFolderResponse
func (c *ClientWithResponses) PostFolderWithResponse(ctx context.Context, params *PostFolderParams, reqEditors ...RequestEditorFn) (*PostFolderResponse, error) {
	rsp, err := c.PostFolder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFolderResponse(rsp)
}

// PostLoginWithBodyWithResponse request with arbitrary body returning *PostLoginResponse
func (c *ClientWithResponses) PostLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLoginResponse, error) {
	rsp, err := c.PostLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLoginResponse(rsp)
}

func (c *ClientWithResponses) PostLoginWithResponse(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLoginResponse, error) {
	rsp, err := c.PostLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLoginResponse(rsp)
}

// PostMoveWithBodyWithResponse request with arbitrary body returning *PostMoveResponse
func (c *ClientWithResponses) PostMoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMoveResponse, error) {
	rsp, err := c.PostMoveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMoveResponse(rsp)
}

func (c *ClientWithResponses) PostMoveWithResponse(ctx context.Context, body PostMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMoveResponse, error) {
	rsp, err := c.PostMove(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMoveResponse(rsp)
}

// GetSearchWithResponse request returning *GetSearchResponse
func (c *ClientWithResponses) GetSearchWithResponse(ctx context.Context, params *GetSearchParams, reqEditors ...RequestEditorFn) (*GetSearchResponse, error) {
	rsp, err := c.GetSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResponse(rsp)
}

// DeleteUserIdWithResponse request returning *DeleteUserIdResponse
func (c *ClientWithResponses) DeleteUserIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserIdResponse, error) {
	rsp, err := c.DeleteUserId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserIdResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// PatchUserIdWithBodyWithResponse request with arbitrary body returning *PatchUserIdResponse
func (c *ClientWithResponses) PatchUserIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserIdResponse, error) {
	rsp, err := c.PatchUserIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserIdResponse(rsp)
}

func (c *ClientWithResponses) PatchUserIdWithResponse(ctx context.Context, id string, body PatchUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserIdResponse, error) {
	rsp, err := c.PatchUserId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserIdResponse(rsp)
}

// PostUserIdWithBodyWithResponse request with arbitrary body returning *PostUserIdResponse
func (c *ClientWithResponses) PostUserIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserIdResponse, error) {
	rsp, err := c.PostUserIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserIdResponse(rsp)
}

func (c *ClientWithResponses) PostUserIdWithResponse(ctx context.Context, id string, body PostUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserIdResponse, error) {
	rsp, err := c.PostUserId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserIdResponse(rsp)
}

// ParseGetAccessTokenResponse parses an HTTP response from a GetAccessTokenWithResponse call
func ParseGetAccessTokenResponse(rsp *http.Response) (*GetAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessToken *string `json:"accessToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlobResponse parses an HTTP response from a GetBlobWithResponse call
func ParseGetBlobResponse(rsp *http.Response) (*GetBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostBlobResponse parses an HTTP response from a PostBlobWithResponse call
func ParsePostBlobResponse(rsp *http.Response) (*PostBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostCopyResponse parses an HTTP response from a PostCopyWithResponse call
func ParsePostCopyResponse(rsp *http.Response) (*PostCopyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFileResponse parses an HTTP response from a DeleteFileWithResponse call
func ParseDeleteFileResponse(rsp *http.Response) (*DeleteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content *string `json:"content,omitempty"`
			Info    *File   `json:"info,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchFileResponse parses an HTTP response from a PatchFileWithResponse call
func ParsePatchFileResponse(rsp *http.Response) (*PatchFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostFileResponse parses an HTTP response from a PostFileWithResponse call
func ParsePostFileResponse(rsp *http.Response) (*PostFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFolderResponse parses an HTTP response from a GetFolderWithResponse call
func ParseGetFolderResponse(rsp *http.Response) (*GetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Files   *[]File   `json:"files,omitempty"`
			Folders *[]Folder `json:"folders,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			Empty *string `json:",omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/javascript) unsupported

	}

	return response, nil
}

// ParsePatchFolderResponse parses an HTTP response from a PatchFolderWithResponse call
func ParsePatchFolderResponse(rsp *http.Response) (*PatchFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostFolderResponse parses an HTTP response from a PostFolderWithResponse call
func ParsePostFolderResponse(rsp *http.Response) (*PostFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostLoginResponse parses an HTTP response from a PostLoginWithResponse call
func ParsePostLoginResponse(rsp *http.Response) (*PostLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostMoveResponse parses an HTTP response from a PostMoveWithResponse call
func ParsePostMoveResponse(rsp *http.Response) (*PostMoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSearchResponse parses an HTTP response from a GetSearchWithResponse call
func ParseGetSearchResponse(rsp *http.Response) (*GetSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Files   *[]File   `json:"files,omitempty"`
			Folders *[]Folder `json:"folders,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			Empty *string `json:",omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/javascript) unsupported

	}

	return response, nil
}

// ParseDeleteUserIdResponse parses an HTTP response from a DeleteUserIdWithResponse call
func ParseDeleteUserIdResponse(rsp *http.Response) (*DeleteUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchUserIdResponse parses an HTTP response from a PatchUserIdWithResponse call
func ParsePatchUserIdResponse(rsp *http.Response) (*PatchUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostUserIdResponse parses an HTTP response from a PostUserIdWithResponse call
func ParsePostUserIdResponse(rsp *http.Response) (*PostUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Your GET endpoint
	// (GET /access-token)
	GetAccessToken(ctx echo.Context) error
	// Your GET endpoint
	// (GET /blob)
	GetBlob(ctx echo.Context, params GetBlobParams) error

	// (POST /blob)
	PostBlob(ctx echo.Context, params PostBlobParams) error

	// (POST /copy)
	PostCopy(ctx echo.Context) error

	// (DELETE /file)
	DeleteFile(ctx echo.Context, params DeleteFileParams) error
	// Your GET endpoint
	// (GET /file)
	GetFile(ctx echo.Context, params GetFileParams) error

	// (PATCH /file)
	PatchFile(ctx echo.Context, params PatchFileParams) error

	// (POST /file)
	PostFile(ctx echo.Context, params PostFileParams) error

	// (DELETE /folder)
	DeleteFolder(ctx echo.Context, params DeleteFolderParams) error
	// Your GET endpoint
	// (GET /folder)
	GetFolder(ctx echo.Context, params GetFolderParams) error

	// (PATCH /folder)
	PatchFolder(ctx echo.Context, params PatchFolderParams) error

	// (POST /folder)
	PostFolder(ctx echo.Context, params PostFolderParams) error

	// (POST /login)
	PostLogin(ctx echo.Context) error

	// (POST /move)
	PostMove(ctx echo.Context) error
	// Your GET endpoint
	// (GET /search)
	GetSearch(ctx echo.Context, params GetSearchParams) error

	// (DELETE /user/{id})
	DeleteUserId(ctx echo.Context, id string) error
	// Your GET endpoint
	// (GET /user/{id})
	GetUser(ctx echo.Context, id string) error

	// (PATCH /user/{id})
	PatchUserId(ctx echo.Context, id string) error

	// (POST /user/{id})
	PostUserId(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccessToken(ctx)
	return err
}

// GetBlob converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlob(ctx echo.Context) error {
	var err error

	ctx.Set(AccessTokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlobParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlob(ctx, params)
	return err
}

// PostBlob converts echo context to params.
func (w *ServerInterfaceWrapper) PostBlob(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostBlobParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBlob(ctx, params)
	return err
}

// PostCopy converts echo context to params.
func (w *ServerInterfaceWrapper) PostCopy(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCopy(ctx)
	return err
}

// DeleteFile converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFile(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteFileParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteFile(ctx, params)
	return err
}

// GetFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetFile(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFile(ctx, params)
	return err
}

// PatchFile converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFile(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchFileParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchFile(ctx, params)
	return err
}

// PostFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostFile(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostFileParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostFile(ctx, params)
	return err
}

// DeleteFolder converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFolder(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteFolderParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteFolder(ctx, params)
	return err
}

// GetFolder converts echo context to params.
func (w *ServerInterfaceWrapper) GetFolder(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFolderParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFolder(ctx, params)
	return err
}

// PatchFolder converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFolder(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchFolderParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchFolder(ctx, params)
	return err
}

// PostFolder converts echo context to params.
func (w *ServerInterfaceWrapper) PostFolder(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostFolderParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostFolder(ctx, params)
	return err
}

// PostLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostLogin(ctx)
	return err
}

// PostMove converts echo context to params.
func (w *ServerInterfaceWrapper) PostMove(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostMove(ctx)
	return err
}

// GetSearch converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearch(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSearchParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Required query parameter "searchQuery" -------------

	err = runtime.BindQueryParameter("form", true, true, "searchQuery", ctx.QueryParams(), &params.SearchQuery)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter searchQuery: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSearch(ctx, params)
	return err
}

// DeleteUserId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUserId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUserId(ctx, id)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// PatchUserId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUserId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchUserId(ctx, id)
	return err
}

// PostUserId converts echo context to params.
func (w *ServerInterfaceWrapper) PostUserId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUserId(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/access-token", wrapper.GetAccessToken)
	router.GET(baseURL+"/blob", wrapper.GetBlob)
	router.POST(baseURL+"/blob", wrapper.PostBlob)
	router.POST(baseURL+"/copy", wrapper.PostCopy)
	router.DELETE(baseURL+"/file", wrapper.DeleteFile)
	router.GET(baseURL+"/file", wrapper.GetFile)
	router.PATCH(baseURL+"/file", wrapper.PatchFile)
	router.POST(baseURL+"/file", wrapper.PostFile)
	router.DELETE(baseURL+"/folder", wrapper.DeleteFolder)
	router.GET(baseURL+"/folder", wrapper.GetFolder)
	router.PATCH(baseURL+"/folder", wrapper.PatchFolder)
	router.POST(baseURL+"/folder", wrapper.PostFolder)
	router.POST(baseURL+"/login", wrapper.PostLogin)
	router.POST(baseURL+"/move", wrapper.PostMove)
	router.GET(baseURL+"/search", wrapper.GetSearch)
	router.DELETE(baseURL+"/user/:id", wrapper.DeleteUserId)
	router.GET(baseURL+"/user/:id", wrapper.GetUser)
	router.PATCH(baseURL+"/user/:id", wrapper.PatchUserId)
	router.POST(baseURL+"/user/:id", wrapper.PostUserId)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xaX2/bNhD/KgTXp02JnKQFCj2t7dqsaLe2a/MwJBnAiCebjUQq5MmOE/i7DyQlS4rp",
	"P0ntLR32FEsk73i/u/vdkcotTVVRKgkSDU1uack0KwBBu6f3KmUolPzIcGSfhaQJvapAT2lEJSuAJrS0",
	"YxHVcFUJDZwmqCuIqElHUDC7CKelnWdQCzmks9nMTjalkgackjcq56BfKYkg0b5I25+sLHPh9xB/ZWNm",
	"Ui1KN7IgX118hRSpFd9bZZTszy+1KkGj8NozkfsfAqFwP55oyGhCf4hbZGK/2sRvRA50FjU6mdZsap8z",
	"Z8M95Lj5i5LaF0vMuS7yVdaE8F4UOYsoBw+lsOjQ19esKHMgjV/cqnqvzkXW7AVleR0dAaURLRQXmbDx",
	"cEszpQuGNKGcIeyhKIBGiyt8PAVEGXHjBgohRVEVNBnMVwuJMOwCeUvB20ITinCNcZkzIWlkwxRBW2P/",
	"Ojub/HR2Fts/TxY3YkUJdAKc2Xfhi+j1nkFV5mI4cpEoOE1oNTia3Nw8L8bIBpUTUrv4UaPWtdVvdzNr",
	"j3LI5cFlURxeXgon5g/lIwSkVXVKGS8c7BqGVc40PW81ual3LQnruZ5eFfrgSKpnhxep03NiQpgKHoRA",
	"15talYluN7OIVgb0Eiw7KDn1m2H0NPsqc30wvH4mLq980hlIKy1w+tnq9jtnaQrGfFGXIJcRbHdKyxel",
	"eAeOerBZ6yyyYxfAdHebI8TSb0DITDUMy1K3VyiYyGnSvPr5Smmxz2Hc6v+ktCCv871fWSZuLNVXOq+l",
	"miSOJ5PJ/nzRArPYFCKfK52BJi8+vqX95OqPjEEbv+pgf2BFqRIkK4UNuH37ymXxyOEWe1T25tYPwZnT",
	"1/7CXJJMaeJmEVTEryKW9AlXE5krxglgSp0y7RLzrfXeMeCLHu69knU4GKwqVGtKzh2fP4CvP7yj3Xii",
	"yeltEwen57PziJqqKJie0oT+qSpNjl9/ISB5qYS04YpsaFySVjii51ZSfJGri6Uw/tIg5XBjSIZiDJLU",
	"lX8BuJdWVtRrJU7DSdhOiXuthjXhHoCrFAH3DGpgRR/4OYdeCMlcUgW6kfXY9jx2H4QdrOeziJbKBIA9",
	"KR2szAOLivg+gnDIhAROxBKQPyqzNZSvKjD4UvHpHYCLKkdRMo2xBXGPM2TrsF3XWbUrphgsZmuboYXm",
	"sQ6Me6bHHffYBEhV6RAIO+qVKqckFwaJypyzDGGS1+4yXX8ZVekUjHUmB4NCOrzrmUFHWtl0lSfuwy0d",
	"neGuwG+v55b1bmib+9O5hKin63xzX21s2aY02HjTudB7M6sbVg45IAQYzb13nlzwiR+re78dkNgDY9Xt",
	"1VJJkKI1YKVlXdlsmd8nIiMWQSIMcZ3wj0QgmYg8J81kgaR2BmFm/rMOqGmI2neHygPjvbNsIYybbmf9",
	"ge4frLlzN5YM01HIkbbt8n50DdgCZdh12/LDNihnRde8W/ZuoQxydqqBIRAJEwJFidNwtlsG/g7QbM+3",
	"/xbMjlbnZ9plxMprYt2sj6mptqmNj4hs/ZaW0u2HEqRt27yZthVoOHV5kyCkERyCrLpDAEIy5vPi/t3b",
	"VvitRW4Jw50Y4LY9qpmOLe2NHNFtDZrvm+o6qK4juyYokTRXTRudJx5zFlruydVQyOUd+ns3HDKsGdlO",
	"CJTMmInSvL5aew9yiCOaHAROM90rpZVT73TY83VRq20X/XXfMPzG+4iIPh0cfIP+Aoxhw7qkZKzK0d1U",
	"jlkuOGkgIUqTOSbRQ7Z6IlmFI6XFDfDe6aFzGVKoMSyPtN/UGHZ1FrSy/z8LbuEs6FzovWmAaV+HgqX8",
	"sxv2DbfSDXta76WqBL7MW8eAfuUiY27lK1kUluON+VS/3FzcI+kOal94x9ikjm8Fn23QUFYm4APfPp4Y",
	"0G853bTyWJ56uiueEg9kpd8VkjeqknzDyujgWNqdHgM6wNxFQChy688Y35SRq07VTv7uztBz60OJV2da",
	"nS+C3zdNVp/LlSbpiMkhdMtQoG/tBOW2u45dfubabRfb+m1dDxtMd1sg/7O4HgQunR0e96QEP1mPm5xo",
	"P9YlcWwPBPlIGUyOBoMB7Sy/nX9ttG2QrT71s7si7zy7S9bOc+b/I6J9bv6zYf7GleLOc10DOm/c1u1m",
	"Qt9Rn+ONutTX48PDdDChs9nfAQAA///NhcSUsiIAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
